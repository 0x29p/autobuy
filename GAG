-- debug flag
local debug_ = false -- debug logs

while not game:IsLoaded() do
    task.wait()
end

local plrs = game:GetService("Players")
while not plrs.LocalPlayer do
    task.wait()
end

local plr = plrs.LocalPlayer

local LOAD_WAIT = 1

local function loadWait()
    while not plr:GetAttribute("Finished_Loading") do
        task.wait()
    end
    while not plr:GetAttribute("DataFullyLoaded") do
        task.wait()
    end
    while not plr:GetAttribute("Setup_Finished") do
        task.wait()
    end
    game:GetService("ReplicatedStorage").GameEvents.Finish_Loading:FireServer()
    game:GetService("ReplicatedStorage").GameEvents.LoadScreenEvent:FireServer(plr)
    while not plr:GetAttribute("Loading_Screen_Finished") do
        task.wait()
    end
    task.wait(LOAD_WAIT)
end

local dprint = debug_ and print or function() end

dprint("waiting for load")

if plr:GetAttribute("Loading_Screen_Finished") then
    game:GetService("ReplicatedStorage").GameEvents.Finish_Loading:FireServer()
    game:GetService("ReplicatedStorage").GameEvents.LoadScreenEvent:FireServer(plr)
else
    loadWait()
end

dprint("loaded")

local GAG = {}

local httpService = game:GetService("HttpService")
local rs = game:GetService("ReplicatedStorage")
local rf = game:GetService("ReplicatedFirst")
local gameEvents = rs:WaitForChild("GameEvents")
local modules = rs.Modules
local dataService = require(modules.DataService)
local notification = require(modules.Notification)
local seedData = require(rs.Data.SeedData)
local marketController = require(modules.MarketController)
local giftController = require(modules.GiftController)
local updateService = require(modules.UpdateService)
local inventoryService = require(modules.InventoryService)

local MAX_PLANTS_ON_FARM = 800 -- ?

local function setConsoleEnabled(bool)
    game:GetService("StarterGui"):SetCore("DevConsoleVisible", bool)
end

local function getHRP()
    while not plr.Character do
        task.wait()
    end
    return plr.Character:FindFirstChild("HumanoidRootPart") or plr.Character:WaitForChild("HumanoidRootPart",9e9)
end

local function round(num,decimals)
    decimals = decimals or 0
    local power = 10^decimals
    return math.round(num*power)/power
end

-- types trimmed for brevity; keep only fields we use

-- PLANTDATA CLASS --
local PlantData = {}
PlantData.__index = function(t,key)
    -- dynamic access for value instances
    if table.find({"Age","Weight","Item_Seed","Variant"}, key) then
        local val = t["_"..key]
        if val then return val.Value end
        return nil
    elseif table.find({"MaxAge","FruitSizeMultiplier","FruitVariantLuck","GrowRateMulti","LuckFruitSizeMultiplier","LuckFruitVariantLuck"}, key) then
        if t._instance then
            return t._instance:GetAttribute(key)
        end
        return nil
    elseif key == "Name" and t._instance then
        return t._instance.Name
    else
        return rawget(PlantData,key) or rawget(t,key)
    end
end

-- FRUITDATA CLASS --
local FruitData = {}
FruitData.__index = function(t,key)
    if table.find({"Age","ItemSeed","Variant","Weight"}, key) then
        local val = t["_"..key]
        if val then return val.Value end
        return nil
    elseif table.find({"GrowRateMulti","MaxAge","UUID","WeightMulti"}, key) then
        if t._instance then
            return t._instance:GetAttribute(key)
        end
        return nil
    elseif key == "Name" and t._instance then
        return t._instance.Name
    else
        return rawget(FruitData,key) or rawget(t,key)
    end
end

function PlantData:HasGrown()
    return (self.Age or 0) >= (self.MaxAge or 0)
end

function PlantData:IsHarvestableWithoutFruit()
    return self._instance and self._instance:FindFirstChild("Fruits")==nil
end

function PlantData:GetFruitsData()
    local fruitsData = {}
    if self._instance and self._instance:FindFirstChild("Fruits") then
        for _, fruitInstance in ipairs(self._instance.Fruits:GetChildren()) do
            table.insert(fruitsData, FruitData.new(fruitInstance))
        end
    elseif self:IsHarvestableWithoutFruit() then
        -- copy self into a fake fruit representation (previous logic kept)
        return {FruitData.new(table.copy(self))}
    end
    return fruitsData
end

function PlantData.new(plantInstance)
    local self = setmetatable({}, PlantData)
    self._Age = plantInstance.Grow and plantInstance.Grow:FindFirstChild("Age") or nil
    self._instance = plantInstance
    self._Weight = plantInstance:FindFirstChild("Weight")
    self._Item_Seed = plantInstance:FindFirstChild("Item_Seed")
    self._Variant = plantInstance:FindFirstChild("Variant")
    return self
end

function FruitData:HasGrown()
    return (self.Age or 0) >= (self.MaxAge or 0)
end

function FruitData:GetPickupPrompt()
    if not self._instance then return nil end
    return self._instance:FindFirstChildWhichIsA("ProximityPrompt",true)
end

function FruitData:CanPickup()
    local p = self:GetPickupPrompt()
    return self:HasGrown() and p and self:IsWithinPickupRange()
end

function FruitData:IsWithinPickupRange()
    local pickupPrompt = self:GetPickupPrompt()
    if not pickupPrompt then return false end
    local hrp = getHRP()
    if not hrp then return false end
    return (pickupPrompt.Parent.Position - hrp.Position).Magnitude < pickupPrompt.MaxActivationDistance
end

function FruitData:GetMutations()
    local mutations = {}
    local all = GAG:GetAllMutations()
    if not all then return mutations end
    for _, mutation in ipairs(all) do
        if self._instance and self._instance:GetAttribute(mutation.Name) then
            table.insert(mutations, mutation.Name)
        end
    end
    return mutations
end

function FruitData.new(fruitInstance)
    local self = setmetatable({}, FruitData)
    self._Age = fruitInstance.Grow and fruitInstance.Grow:FindFirstChild("Age") or nil
    self._ItemSeed = fruitInstance:FindFirstChild("Item_Seed")
    self._Variant = fruitInstance:FindFirstChild("Variant")
    self._Weight = fruitInstance:FindFirstChild("Weight")
    self._instance = fruitInstance
    return self
end

function GAG:GetOwnFarmFolder()
    if not workspace:FindFirstChild("Farm") then return nil end
    for _, farm in ipairs(workspace.Farm:GetChildren()) do
        local data = farm:FindFirstChild("Important") and farm.Important:FindFirstChild("Data")
        if data and data:FindFirstChild("Owner") and data.Owner.Value == plr.Name then
            return farm
        end
    end
    return nil
end

function GAG:BuySeed(seedName)
    gameEvents.BuySeedStock:FireServer(seedName)
end

function GAG:SellFruitInHand()
    gameEvents.Sell_Item:FireServer()
end

function GAG:SellAllFruitsInInventory()
    gameEvents.Sell_Inventory:FireServer()
end

function GAG:PlantSeed(seedName, plantPosition)
    gameEvents.Plant_RE:FireServer(plantPosition, seedName)
end

function GAG:GetLastSeedShopResetTimestamp()
    return dataService:GetData().SeedStock.ForcedSeedEndTimestamp
end

function GAG:GetSeedShopStock()
    return dataService:GetData().SeedStock.Stocks
end

function GAG:GetLastPetEggShopResetTimestamp()
    return dataService:GetData().PetEggStock.ForcedEggEndTimestamp
end

function GAG:IsInventoryFull()
    return inventoryService:IsMaxInventory()
end

-- InventoryItem class
local InventoryItem = {}
InventoryItem.__index = InventoryItem

function InventoryItem:GetTool()
    local backpack = plr:FindFirstChild("Backpack")
    if backpack then
        for _, v in ipairs(backpack:GetChildren()) do
            if v:GetAttribute("ITEM_UUID") == self.UUID or v:GetAttribute("PET_UUID") == self.UUID then
                return v
            end
        end
    end
    if plr.Character then
        local charTool = plr.Character:FindFirstChildWhichIsA("Tool")
        if charTool and (charTool:GetAttribute("ITEM_UUID") == self.UUID or charTool:GetAttribute("PET_UUID") == self.UUID) then
            return charTool
        end
    end
    return nil
end

function InventoryItem.new(dict)
    return setmetatable(dict, InventoryItem)
end

function InventoryItem.fromInventory(itemUUID)
    local data = dataService:GetData()
    local item = data.InventoryData[itemUUID] or (data.PetsData and data.PetsData.PetInventory.Data[itemUUID])
    if not item then return nil end
    item.UUID = itemUUID
    return InventoryItem.new(item)
end

function InventoryItem.fromTool(tool)
    if not tool then return nil end

    local uuidValueInstance = tool:FindFirstChild("ITEM_UUID") or tool:FindFirstChild("PET_UUID")
    if uuidValueInstance then
        dprint("returning from inventory")
        return InventoryItem.fromInventory("{"..uuidValueInstance.Value.."}")
    end

    local toolAttributeStringMappings = {
        ["Favorite"] = "IsFavorite",
        ["ITEM_TYPE"] = "ItemType",
        ["ITEM_UUID"] = "UUID",
        ["ItemName"] = "ItemName",
        ["ItemType"] = "ItemType",
        ["WeightMulti"] = "WeightMultiplier",
        ["Quantity"] = "Quantity",
        ["PET_UUID"] = "UUID"
    }

    local toolValueInstanceNameMappings = {
        ["Item_Seed"] = "Seed",
        ["Item_String"] = "ItemName",
        ["Variant"] = "Variant",
        ["Weight"] = "Weight"
    }

    local mutationStrings = {}

    local allMut = GAG:GetAllMutations()
    if allMut then
        for _, v in ipairs(allMut) do
            if tool:GetAttribute(v.Name) then
                table.insert(mutationStrings, v.Name)
            end
        end
    end

    local inventoryItem = {}
    local isPet = tool:GetAttribute("PET_UUID") ~= nil
    local dataPath

    if isPet then
        inventoryItem.PetData = {}
        dataPath = inventoryItem.PetData
    else
        inventoryItem.ItemData = {}
        dataPath = inventoryItem.ItemData
    end

    if #mutationStrings > 0 then
        dataPath.MutationString = table.concat(mutationStrings,", ")
    end

    for attribute, mapping in pairs(toolAttributeStringMappings) do
        local val = tool:GetAttribute(attribute)
        if val ~= nil then
            dataPath[mapping] = val
        end
    end

    for valueInstanceName, mapping in pairs(toolValueInstanceNameMappings) do
        local valueInstance = tool:FindFirstChild(valueInstanceName)
        if valueInstance then
            dataPath[mapping] = valueInstance.Value
        end
    end

    inventoryItem.UUID = dataPath.UUID or (dataPath.ItemName and ("{"..tostring(dataPath.ItemName).."}")) -- best-effort
    inventoryItem.ItemType = dataPath.ItemType

    return InventoryItem.new(inventoryItem)
end

function InventoryItem:IsSeedOrFruit()
    local cls = self:GetClass()
    if cls ~= "Holdable" and cls ~= "Seed" then
        return false
    end
    return seedData and seedData[self.ItemData and self.ItemData.ItemName] and true or false
end

function GAG:IsSeedOrFruit(itemName)
    return seedData and seedData[itemName] and true or false
end

function InventoryItem:GetClass()
    return self.ItemType
end

function InventoryItem:IsSeed()
    return self:GetClass() == "Seed"
end

function InventoryItem:IsFruit()
    return self:IsSeedOrFruit() and (not self:IsSeed()) and true
end

function GAG:NightQuestSubmitHeldPlant()
    gameEvents.NightQuestRemoteEvent:FireServer("SubmitHeldPlant")
end

function GAG:NightQuestSubmitAllPlants()
    gameEvents.NightQuestRemoteEvent:FireServer("SubmitAllPlants")
end

function GAG:GetNextGlobalUpdateTimestamp()
    return rf.GlobalUpdateTime.Value
end

function GAG:GetCurrentBiome()
    return plr.Current_Biome.Value
end

local NightEventShopItems = require(rs.Data.NightEventShopData)

function GAG:BuyNightEventShopItem(itemName)
    gameEvents.BuyNightEventShopStock:FireServer(itemName)
end

function GAG:GetPetEggsStock()
    local eggs = {}
    local stocks = dataService:GetData().PetEggStock.Stocks
    for _, eggTable in pairs(stocks) do
        table.insert(eggs, { ItemName = eggTable.EggName, Stock = eggTable.Stock, MaxStock = nil })
    end
    return eggs
end

function GAG:GetNightEventShopStock()
    local stocks = {}
    for itemName, stock in pairs(dataService:GetData().NightEventShopStock.Stocks) do
        table.insert(stocks, { ItemName = itemName, Stock = stock.Stock, MaxStock = stock.MaxStock })
    end
    return stocks
end

function GAG:GetEventShopStock()
    local stocks = {}
    for itemName, stock in pairs(dataService:GetData().EventShopStock.Stocks) do
        table.insert(stocks, { ItemName = itemName, Stock = stock.Stock, MaxStock = stock.MaxStock })
    end
    return stocks
end

function GAG:GetGearStock()
    local stocks = {}
    for itemName, stock in pairs(dataService:GetData().GearStock.Stocks) do
        table.insert(stocks, { ItemName = itemName, Stock = stock.Stock, MaxStock = stock.MaxStock })
    end
    return stocks
end

function GAG:GetCosmeticStock()
    local CrateStocks = {}
    local ItemStocks = {}
    for stocksObjectName, stockObjects in pairs(dataService:GetData().CosmeticStock) do
        if stocksObjectName == "CrateStocks" then
            for _, v in ipairs(stockObjects) do
                v.ItemName = v.CrateName
                table.insert(CrateStocks, v)
            end
        elseif stocksObjectName == "ItemStocks" then
            for i, v in pairs(stockObjects) do
                v.ItemName = i
                table.insert(ItemStocks, v)
            end
        end
    end
    return {
        CrateStocks = CrateStocks,
        ItemStocks = ItemStocks
    }
end

function GAG:CalculateFruitValueMultiplierFromMutations(fruit)
    local v294 = 1
    if fruit and fruit.MutationString and fruit.MutationString ~= "" then
        for _, mutation in ipairs(GAG:GetAllMutations() or {}) do
            if string.find(fruit.MutationString, mutation.Name) then
                v294 = v294 + (mutation.ValueMulti - 1)
            end
        end
    end
    return math.max(1, v294)
end

local LocationCFrames = {
    SellCFrame = CFrame.new(86.5854721, 2.76619363, 0.426784277, 0, 0, -1, 0, 1, 0, 1, 0, 0),
    SeedsShopCFrame = CFrame.new(86.5854721, 2.76619363, -27.0039806, 0, 0, -1, 0, 1, 0, 1, 0, 0),
    GearShopCFrame = CFrame.new(-284.41452, 2.76619363, -32.9778976, 0, 0, 1, 0, 1, -0, -1, 0, 0),
    EventCFrame = CFrame.new(-100.685043, 0.90001297, -11.6456203, 0, 1, 0, 0, 0, 1, 1, 0, 0),
    PetEggShopCFrame = CFrame.new(-285.279419, 2.99999976, -32.4928207, 0.0324875265, -9.37526856e-09, 0.999472141, 1.13912598e-07, 1, 5.67752734e-09, -0.999472141, 1.13668023e-07, 0.0324875265)
}

setmetatable(LocationCFrames,{
    __index = function(t,k)
        if k == "GardenCFrame" then
            local own = GAG:GetOwnFarmFolder()
            if own and own:FindFirstChild("Spawn_Point") then
                return own.Spawn_Point.CFrame
            end
        end
    end
})

local function TPLocation(locationCFrame)
    if plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
        plr.Character.HumanoidRootPart.CFrame = locationCFrame
    end
end

function GAG:IsBloodMoonActive()
    return workspace:GetAttribute("BloodMoonEvent")
end

function GAG:GetEquippedPetUUIDs()
    return dataService:GetData().PetsData.EquippedPets or {}
end

function GAG:GetPetUUIDsInInventory()
    local uuids = {}
    for uuid, _ in pairs(dataService:GetData().PetsData.PetInventory.Data or {}) do
        table.insert(uuids, uuid)
    end
    return uuids
end

-- PetInventoryItem class
local PetInventoryItem = {}
PetInventoryItem.__index = PetInventoryItem

function PetInventoryItem.fromInventory(petItemData)
    return setmetatable(petItemData, PetInventoryItem)
end

function PetInventoryItem:EquipPet(spawnCFrame)
    gameEvents.PetsService:FireServer("EquipPet", self.UUID, spawnCFrame)
end

function PetInventoryItem:UnequipPet()
    gameEvents.PetsService:FireServer("UnequipPet", self.UUID)
end

function PetInventoryItem:FeedPetItemFromHand()
    gameEvents.ActivePetService:FireServer("Feed", self.UUID)
end

function GAG:GetPetByUUID(petUUID)
    local petInventoryItem = dataService:GetData().PetsData.PetInventory.Data[petUUID]
    if not petInventoryItem then return nil end
    petInventoryItem.UUID = petUUID
    return PetInventoryItem.fromInventory(petInventoryItem)
end

function GAG:GetEquippedPets()
    local equippedUUIDs = GAG:GetEquippedPetUUIDs()
    local petInventoryItems = {}
    for _, uuid in ipairs(equippedUUIDs) do
        local pet = GAG:GetPetByUUID(uuid)
        if pet then table.insert(petInventoryItems, pet) end
    end
    return petInventoryItems
end

function GAG:GetPetsInInventory()
    local petUUIDs = GAG:GetPetUUIDsInInventory()
    local petInventoryItems = {}
    for _, uuid in ipairs(petUUIDs) do
        local pet = GAG:GetPetByUUID(uuid)
        if pet then table.insert(petInventoryItems, pet) end
    end
    return petInventoryItems
end

function GAG:BuyEventShopItem(itemName)
    gameEvents.BuyEventShopStock:FireServer(itemName)
end

function GAG:IsNightEventActive()
    return workspace:GetAttribute("NightEvent")
end

function GAG:GetInventory()
    local items = {}
    for uuid, itemTable in pairs(dataService:GetData().InventoryData or {}) do
        local inventoryItem = itemTable
        inventoryItem.UUID = uuid
        table.insert(items, InventoryItem.new(inventoryItem))
    end
    return items
end

function GAG:GetAllMutations()
    local MutationHandler = require(rs.Modules.MutationHandler)
    local mutations = {}
    for _, mutation in ipairs(MutationHandler:GetMutations() or {}) do
        table.insert(mutations, mutation)
    end
    return mutations
end

function GAG:GetShecklesCurrency()
    return dataService:GetData().Sheckles or 0
end

function GAG:PlantEggInHand(eggPosition)
    gameEvents.PetEggService:FireServer("CreateEgg", Vector3.new(eggPosition.X, 0.13552704453468323, eggPosition.Z))
end

function GAG:GetSavedObjects()
    local objects = {}
    for uuid, objectTable in pairs(dataService:GetData().SavedObjects or {}) do
        local object = objectTable
        object.UUID = uuid
        table.insert(objects, object)
    end
    return objects
end

function GAG:GetPlantedEggObjects()
    local eggs = {}
    for _, object in pairs(GAG:GetSavedObjects()) do
        if object.ObjectType == "PetEgg" then
            table.insert(eggs, object)
        end
    end
    return eggs
end

function GAG:HatchEgg(eggInstance)
    gameEvents.PetEggService:FireServer("HatchPet", eggInstance)
end

function GAG:BuyEggFromPetEggShop(eggIndex)
    gameEvents.BuyPetEgg:FireServer(eggIndex)
end

local petRegistry = require(rs.Data.PetRegistry)

function GAG:GetPetMaxHunger(petName)
    return petRegistry.PetList[petName] and petRegistry.PetList[petName].DefaultHunger
end

function GAG:GetPlantsOnFarm()
    local plantsData = {}
    local own = GAG:GetOwnFarmFolder()
    if not own or not own:FindFirstChild("Important") or not own.Important:FindFirstChild("Plants_Physical") then return plantsData end
    for _, plantInstance in ipairs(own.Important.Plants_Physical:GetChildren()) do
        table.insert(plantsData, PlantData.new(plantInstance))
    end
    return plantsData
end

function GAG:GetFruitsOnFarm()
    local fruits = {}
    for _, plantData in ipairs(GAG:GetPlantsOnFarm()) do
        for _, fruitData in ipairs(plantData:GetFruitsData()) do
            table.insert(fruits, fruitData)
        end
    end
    return fruits
end

function GAG:GetMaxEquippedPets()
    return dataService:GetData().PetsData.MutableStats.MaxEquippedPets
end

function GAG:GetMaxPetsInInventory()
    return dataService:GetData().PetsData.MutableStats.MaxPetsInInventory
end

function GAG:GetMaxEggsInFarm()
    return dataService:GetData().PetsData.MutableStats.MaxEggsInFarm
end

-- AbstractItem
local AbstractItem = {}
AbstractItem.__index = AbstractItem

function AbstractItem.new(abstractItem)
    return setmetatable(abstractItem, AbstractItem)
end

function AbstractItem:GetClass()
    return self._toolInstance and self._toolInstance:GetAttribute("ItemType")
end

function AbstractItem:GetTool()
    return self._toolInstance
end

function GAG:ShovelPlant(instance)
    gameEvents.Remove_Item:FireServer(instance)
end

function GAG:GetRandomPlantingLocation()
    local own = GAG:GetOwnFarmFolder()
    if not own or not own:FindFirstChild("Important") or not own.Important:FindFirstChild("Plant_Locations") then
        return Vector3.new(0,0,0)
    end
    local plantLocations = own.Important.Plant_Locations:GetChildren()
    if #plantLocations == 0 then return Vector3.new(0,0,0) end
    local plantLocation = plantLocations[math.random(#plantLocations)]
    local position = plantLocation.Position
    local size = plantLocation.Size

    local randomX = position.X + (math.random() - 0.5) * size.X
    local randomZ = position.Z + (math.random() - 0.5) * size.Z

    return Vector3.new(randomX, 0.13552704453468323, randomZ)
end

function GAG:SetSetting(setting, boolean)
    gameEvents.SettingsService:FireServer("SetSetting", setting, boolean)
end

function GAG:RedeemCode(code)
    gameEvents.ClaimableCodeService:FireServer("ClaimCode", code)
end

function GAG:GetSpecialCurrency(currencyName)
    local specialCurrency = dataService:GetData().SpecialCurrency
    if (not specialCurrency) or (not specialCurrency[currencyName]) then
        return -1
    end
    return specialCurrency[currencyName]
end

function GAG:GetHoneyCurrency()
    return GAG:GetSpecialCurrency("Honey")
end

function GAG:GetFruitsInInventory()
    local fruits = {}
    for _, item in ipairs(GAG:GetInventory()) do
        if item and item.ItemData and GAG:IsSeedOrFruit(item.ItemData.ItemName) and item:IsFruit() then
            table.insert(fruits, item)
        end
    end
    return fruits
end

local MAX_HONEY_MACHINE_PLANT_WEIGHT = 10

function GAG:GetHoneyMachineState()
    return dataService:GetData().HoneyMachine
end

function GAG:IsHoneyMachineFull()
    local st = GAG:GetHoneyMachineState()
    return st and st.PlantWeight >= MAX_HONEY_MACHINE_PLANT_WEIGHT
end

function GAG:GivePlantToHoneyMachineFromHand()
    gameEvents.HoneyMachineService_RE:FireServer("MachineInteract")
end

function GAG:BuyCosmeticItem(itemName)
    gameEvents.BuyCosmeticItem:FireServer(itemName)
end

function GAG:BuyCosmeticCrate(crateName)
    gameEvents.BuyCosmeticCrate:FireServer(crateName)
end

function GAG:ScrapeDevProducts()
    local marketplaceService = cloneref(game:GetService("MarketplaceService"))
    local pages = marketplaceService:GetDeveloperProductsAsync()
    local items = {}
    while true do
        table.insert(items, pages:GetCurrentPage())
        if pages.IsFinished then break end
        pages:AdvanceToNextPageAsync()
    end
    return items
end

function GAG:ToggleFavoriteItem(tool)
    gameEvents.Favorite_Item:FireServer(tool)
end

function GAG:ScrapeAllWeathers()
    local attr = workspace:GetAttribute("AllWeather")
    if not attr then return nil end
    return httpService:JSONDecode(attr)
end

-- CollectableSeed class
local CollectableSeed = {}
CollectableSeed.__index = CollectableSeed

function CollectableSeed:GetTouchInterest()
    return self._instance.PrimaryPart and self._instance.PrimaryPart:FindFirstChildWhichIsA("TouchTransmitter")
end

function CollectableSeed.new(dict)
    return setmetatable(dict, CollectableSeed)
end

function GAG:GetCollectableSeeds()
    local collectableSeeds = {}
    for _, v in ipairs(workspace:GetChildren()) do
        if v:IsA("Model") then
            local owner = v:GetAttribute("OWNER")
            local seedGiven = v:GetAttribute("SEED_GIVEN")
            if owner and seedGiven then
                table.insert(collectableSeeds, CollectableSeed.new({
                    Name = seedGiven,
                    OWNER = owner,
                    _instance = v
                }))
            end
        end
    end
    return collectableSeeds
end

function GAG:GivePetInHand(targetPlayer)
    gameEvents.PetGiftingService:FireServer("GivePet", targetPlayer)
end

local autoPetGiftsConnection

function GAG:AutoAcceptPetGifts(enable)
    if enable then
        autoPetGiftsConnection = gameEvents.GiftPet.OnClientEvent:Connect(function(uuid, fullPetName, offeringPlayer)
            gameEvents.AcceptPetGift:FireServer(true, uuid)
        end)
    elseif autoPetGiftsConnection then
        autoPetGiftsConnection:Disconnect()
        autoPetGiftsConnection = nil
    end
end

function GAG:RemoveBracketsFromUUID(uuid)
    if type(uuid) ~= "string" then return uuid end
    return uuid:sub(2, -2)
end

function GAG:GiftItemInHand(targetPlayer)
    local prompt = targetPlayer.Character and targetPlayer.Character:FindFirstChildWhichIsA("ProximityPrompt",true)
    if prompt then
        fireproximityprompt(prompt)
    end
end

function GAG:LikeGarden(player)
    gameEvents.LikeGarden:InvokeServer(player)
end

function GAG:GetPetEggInstanceByUUID(uuid)
    local own = GAG:GetOwnFarmFolder()
    if not own or not own:FindFirstChild("Important") or not own.Important:FindFirstChild("Objects_Physical") then return nil end
    for _, eggInstance in ipairs(own.Important.Objects_Physical:GetChildren()) do
        if eggInstance:GetAttribute("OBJECT_TYPE") == "PetEgg" and eggInstance:GetAttribute("OBJECT_UUID") == uuid then
            return eggInstance
        end
    end
    return nil
end

function GAG:RejoinServer()
    local tpService = game:GetService("TeleportService")
    tpService.TeleportInitFailed:Connect(function()
        tpService:Teleport(game.PlaceId)
    end)
    tpService:Teleport(game.PlaceId)
end

function GAG:GetToolInHand()
    if plr.Character then
        return plr.Character:FindFirstChildWhichIsA("Tool")
    end
    return nil
end

return GAG
